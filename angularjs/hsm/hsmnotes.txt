event handling in the presence of parallel states is not well described in the literature, what ive chosen to do amounts to capturing down a region tree, and -- while bubbling up -- capture and bubble up each state tree.

thoughts towards a better implementation:

	* the state descriptions should be read-only: this is not particularly useful in angular, but would be useful in other implementations where we could store the states to data.

	* a tree of active regions should be built dynamically: this would need to happen on start(), enter/init() from lca, an active region stack can be built during the various calls for use in finding region lca.

	* region depth and state depth should be tracked separately.

	* the active region record should contain the (single) leaf state, we can walk up to find the full active tree; basically: the region code should devolve into the simple case with no extra overhead.  

	* events within each state tree should emit, rather than capture and bubble.

	* it would be awesome if exit transitions could be partially handled during region bubbling -- we dont bother to emit into the state trees of regions we have already exited.

	* its possible that a state machine object is just the top active region record.

	* the lca alg -- and enter, exit in general -- should happen in two tiers: region and state. for any given transition, first seek the common region, exit, enter the lca passing separated bunches of state paths

	* regarding a state that has parallel children -- we need to know that, so when we activate the state we can create the active region node.

		 i think that precludes this: the root of every state description should be a region description ( or null for root, if needed ) and the parent of each region description should be a region region: regions may -- in their entirety -- be a run time concept.

	* state names should always be unique, to reuse states parents can parameterize -- possibly, via ng-init with ng-include, or possibly a custom hsm-include. it's probably not possible to test uniqueness until startup time. relative path addressing is possible -- but need a lot of thought to see how they could go wrong.

angular specifics:

	* hsm-enter should be allowed a return value: a function that is called on exit.
 	* we should be able to have an onEvent generic hook for machines and states
 	* consider hsm-enter, hsm-exit tags to mimic the hsm-event tag.
 	* might be nice to have multiple actions in hsm-enter; could use "; syntax", and split the string before sending to angular parse?
	* need real tests
	* allow scope for region events? raise on regions vs. raise on machine (broadcast vs .emit)
	* find a way to catch  errors thrown by controls and log the html/line of the event,state.

a few state patterns so far:

  "flow chart" -- ex. initialization, enter runs an action, which we wait for in the state, to goto the next action: initialization data gets passed along via events, floated via services, or traded with a parent control. granularity of the stages should depend on whether a stage has a meanigful user interface distinction: ex. erroring out, progress bar, loading screen changes, etc.
  
  "follow chart" - ex. map load, processing, somebody somewhere runs an action we change our state -- summarily -- based on that suddenly appearing event.

  "presentation chart" -- ex. console, somebody somewhere runs an action expecting a particular response. it raises an event which has packed up those action parameters. the machine goes to a state -- often parallel -- enter and init, using the data from that event, customizes the presentation.

  event delegates -- dont really know what these would look like in angular, but basically, a way to custom the behavior of specific event hooks within the state machine ( ie. customizing on-event via on-enter ). this would enable "plugins" for behavior of the current room, etc. without having to add specific states for each room: rather just rooms generically.

	actions should generally perform some task, and in doing so raise an event.
	one good exception to the rule: user input. we'd rather handle the behavior in the machine -- and only raise the event.
   
	scoped events: start/stop for asynchronous behavior.
          