to do:
	. handle conflicting enter paths from different transitions
	. possibly clean up builder to record state names, and hold off state creation until some .finalize() to make state records truly read-only.

..........
angular specifics:

	* ng-include disrupts the order of states, why? yes, it's asynchronous -- but the states get appended rather than injected.....
	* hsm-enter should be allowed a return value: a function that is called on exit.
 	* we should be able to have an onEvent generic hook for machines and states
 	* consider hsm-enter, hsm-exit tags to mimic the hsm-event tag.
 	* might be nice to have multiple actions in hsm-enter; could use "; syntax", and split the string before sending to angular parse?
	* need real tests
	* allow scope for region events? raise on regions vs. raise on machine (broadcast vs .emit)
	* find a way to catch  errors thrown by controls and log the html/line of the event,state.

	* state names should always be unique, to reuse states parents can parameterize -- possibly, via ng-init with ng-include, or possibly a custom hsm-include. it's probably not possible to test uniqueness until startup time. relative path addressing is possible -- but need a lot of thought to see how they could go wrong.

....
some advantages of directiveAs: 

	unifies directive, controller, service.
  you can configure -- best example is log.
  you can reuse hierarchically -- ex. log.
  you can start and stop -- ex. action service, game. -- which means you can host multiple in the same app even if you wanted.
  services still good for true singletons: ex. console access ( but not log ), screen access (but not viewport ), http access ( but not endpoint ).
  you can shim old services with some work.

..........
a few state patterns so far:

  "flow chart" -- ex. initialization, enter runs an action, which we wait for in the state, to goto the next action: initialization data gets passed along via events, floated via services, or traded with a parent control. granularity of the stages should depend on whether a stage has a meanigful user interface distinction: ex. erroring out, progress bar, loading screen changes, etc.
  
  "follow chart" - ex. map load, processing, somebody somewhere runs an action we change our state -- summarily -- based on that suddenly appearing event.

  "presentation chart" -- ex. console, somebody somewhere runs an action expecting a particular response. it raises an event which has packed up those action parameters. the machine goes to a state -- often parallel -- enter and init, using the data from that event, customizes the presentation.

  event delegates -- dont really know what these would look like in angular, but basically, a way to custom the behavior of specific event hooks within the state machine ( ie. customizing on-event via on-enter ). this would enable "plugins" for behavior of the current room, etc. without having to add specific states for each room: rather just rooms generically.

	actions should generally perform some task, and in doing so raise an event.
	one good exception to the rule: user input. we'd rather handle the behavior in the machine -- and only raise the event.
   
	scoped events: start/stop for asynchronous behavior.


.......
general alg: exit up to lca of *source* and target.
	
	0. go to deepest depth, emit on the way back up, until some source state yields a target.
	1. exit from *current* to source if need be.
	2x. check for self transition -- the source and target are the same.
	3a. (edge deeper) either: exit from current/source up to target depth;
	3b. (target deeper) or: track from target up to current/source depth.
	4. (depth matches) exit current/target till matched
			note: we dont exit the state that is matched.
	5. enter path

.......
region alg:
	
	0a. for every region, go to deepest depth;
	0b. on the way back up, emit (inside each region ) til some source yields a target.
  *. a target means transition is desired.

	1. exit from current edge up to source ( unless our edge was the source ), 
				the edge starts at the leaf, if we exit the leaf, exit the leaf's set first.

	2x. check for self transition ( we are still in this region. )
				we dont need a path or anyhing, just enter/init -- but do so down to the fingertips -- just as we did on start.
				actually leaves edge higher than tgt!

	3b. (target deeper)  roll up target up until edge depth -- this doesnt have to worry about regions: they dont exist on this side of the fence.

	3a. (edge deeper) exit edge up until target depth, or until we've poped out of this region; ( returning "target" might be enough; )
			if we've popped out of the region: we will probably be exiting all siblings too, unless the leaf on the parent region is the target, but hold off till we see what happens with -- if we do exit that leaf -- we have to stop emitting to its siblings.


	4. (matched depth; possibly unmatched states)
		exit state, if we exit fully exit a leaf - exit all leaf sub-regions.
		roll up target.

	5. enter from here on down following the path

	the roll up /reenter list is unique to each #0b effort. 

....
its interesting to note: by holding transition actions till the end, then this rising exit algorithm works really well: we dont get unexpected actions if a higher layer decides to transition. at any point, we either have one transition for the top most region, or a list of inner transitions from leaf sets.

/////////////
// (0,h+--1,A)...| A/1 (2,j---3,w)
//               | A/2 (2,i+--3,x) 
//               |     (2,i+--3,B)...| B/1 (4,l--5,y)
//               |                   |     (4,l--5,t)
//               |                   | B/2 (4,m--5,z)
//               | A/3 (2,k)
// 0,(h+--1,q)

( named as: depth,state; a slash means parallel. )
container states: A,B; these are marked parallel
head states: h, j, i, l, m, k
leaf states: A, w, x, B, y, t, z, q, k
regions: h-A, j-w, i-x, i-B, l-y, l-t, m-z, h-q, k
region sets: A/, B/

Machine:
	children: State[]
	-region: Region, for the active state chain.
		
		-leafSet: RegionSet
			 regions: Region[], for event capturing.
		
		-leafState: State
			parent: State, for event bubbling and walking to lca.
			children: State[], for default init and region activation.