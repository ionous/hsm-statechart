to do:
	. handle conflicting enter paths from different transitions

.......
general alg: exit up to lca of *source* and target.
	
	0. go to deepest depth, emit on the way back up, until some source state yields a target.
	1. exit from *current* to source if need be.
	2x. check for self transition -- the source and target are the same.
	3a. (edge deeper) either: exit from current/source up to target depth;
	3b. (target deeper) or: track from target up to current/source depth.
	4. (depth matches) exit current/target till matched
			note: we dont exit the state that is matched.
	5. enter path

.......
region alg:
	
	0a. for every region, go to deepest depth;
	0b. on the way back up, emit (inside each region ) til some source yields a target.
  *. a target means transition is desired.

	1. exit from current edge up to source ( unless our edge was the source ), 
				the edge starts at the leaf, if we exit the leaf, exit the leaf's set first.

	2x. check for self transition ( we are still in this region. )
				we dont need a path or anyhing, just enter/init -- but do so down to the fingertips -- just as we did on start.
				actually leaves edge higher than tgt!

	3b. (target deeper)  roll up target up until edge depth -- this doesnt have to worry about regions: they dont exist on this side of the fence.

	3a. (edge deeper) exit edge up until target depth, or until we've poped out of this region; ( returning "target" might be enough; )
			if we've popped out of the region: we will probably be exiting all siblings too, unless the leaf on the parent region is the target, but hold off till we see what happens with -- if we do exit that leaf -- we have to stop emitting to its siblings.


	4. (matched depth; possibly unmatched states)
		exit state, if we exit fully exit a leaf - exit all leaf sub-regions.
		roll up target.

	5. enter from here on down following the path

	the roll up /reenter list is unique to each 0b effort. 

/////////////
[h|1--[A|2,1(i-.--B)|3,1(l-.-C)|(4,1(n-v-y)
		 	  |2,2(j-,-w) |3,2(m)    |(4,2(o---z)
		    |2,3(k--x)   


container states: A-C; these are marked parallel
head states: h-o
leaf states: A, B, w, x, C, m, y, z
region sets: 2, 3, 4
regions: h, 2.1, 2.2, 2.3; 3.1, 3.2: 4.1, 4.2

Machine:
	-region: Region

		-leafSet: RegionSet
			parent: Region
			container: State
			regions: Region[]


		-leafState: State
			parent: State
			children: State[]

........
its interesting to note: if we do hold off transition actions till the end, then this rising exit algorithm works really well: we dont get unexpected actions if a higher layer decides to transition.

and, at any point, we either have one transition for the top most region, or a list of transits from some leaf set.
